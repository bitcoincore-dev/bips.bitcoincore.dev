<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="share and save bitcoin BIPs">
    <meta name="keywords" content="bitcoin, bitcoin improvement proposals, bip, bips, static, share">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="/style.css" />

    <title>bips.dev - BIP 324</title>
</head>

<body>
    <section class="section">
        <div class="container">
            
    <div class="level">
        <div class="level-left">
            <div class="level-item">
                <a href="/"><img src="/bips-dev-header.png" width="375", height="100" /></a>
            </div>
        </div>
        <div class="level-right">
            <div class="level-item">
                <a href="/">Back to BIPs</a>
            </div>
        </div>
    </div>

    <p class="is-size-3 has-text-weight-bold mb-0">
      BIP 324: Version 2 P2P Encrypted Transport Protocol
    </p>
    <div class="level is-mobile">
        <div class="level-left">
            <div class="level-item">
                <p class="subtitle"><strong>2019-03-08</strong></p>
            </div>
        </div>
        <div class="level-right">
            <div class="level-item">
                <a href="https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;blob&#x2F;master&#x2F;bip-0324.mediawiki">View on GitHub</a>
            </div>
        </div>
    </div>

    <div class="content">
      <pre style="background-color:#fafafa;color:#61676c;"><code><span>  BIP: 324
</span><span>  Layer: Peer Services
</span><span>  Title: Version 2 P2P Encrypted Transport Protocol
</span><span>  Author: Dhruv Mehta &lt;dhruv@bip324.com&gt;
</span><span>          Tim Ruffing &lt;crypto@timruffing.de&gt;
</span><span>          Jonas Schnelli &lt;dev@jonasschnelli.ch&gt;
</span><span>          Pieter Wuille &lt;bitcoin-dev@wuille.net&gt;
</span><span>  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324
</span><span>  Status: Draft
</span><span>  Type: Standards Track
</span><span>  Created: 2019-03-08
</span><span>  License: BSD-3-Clause
</span><span>  Replaces: 151
</span></code></pre>
<h2 id="Introduction">Introduction</h2>
<h3 id="Abstract">Abstract</h3>
<p>This document proposes a new Bitcoin P2P transport protocol, which
features opportunistic encryption, a mild bandwidth reduction, and the
ability to negotiate upgrades before exchanging application messages.</p>
<h3 id="Copyright">Copyright</h3>
<p>This document is licensed under the 3-clause BSD license.</p>
<h3 id="Motivation">Motivation</h3>
<p>Bitcoin is a permissionless network whose purpose is to reach consensus
over public data. Since all data relayed in the Bitcoin P2P network is
inherently public, and the protocol lacks a notion of cryptographic
identities, peers talk to each other over unencrypted and
unauthenticated connections. Nevertheless, this plaintext nature of the
current P2P protocol (referred to as v1 in this document) has severe
drawbacks in the presence of attackers:</p>
<ul>
<li>While the relayed data itself is public in nature, the associated
metadata may reveal private information and hamper privacy of users.
For example, a global passive attacker eavesdropping on all Bitcoin
P2P connections can trivially identify the source and timing of a
transaction.</li>
<li>Since connections are unauthenticated, they can be tampered with at a
low cost and often even with a low risk of detection. For example, an
attacker can alter specific bytes of a connection (such as node flags)
on-the-fly without the need to keep any state.</li>
<li>The protocol is self-revealing. For example, deep packet inspection
can identify a P2P connection trivially because connections start with
a fixed sequence of magic bytes. The ability to detect connections
enables censorship and facilitates the aforementioned attacks as well
as other attacks which require the attacker to control the connections
of victims, e.g., eclipse attacks targeted at miners.</li>
</ul>
<p>This proposal for a new P2P protocol version (v2) aims to improve upon
this by raising the costs for performing these attacks substantially,
primarily through the use of unauthenticated, opportunistic transport
encryption. In addition, the bytestream on the wire is made pseudorandom
(i.e., indistinguishable from uniformly random bytes) to a passive
eavesdropper.</p>
<ul>
<li>Encryption, even when it is unauthenticated and only used when both
endpoints support v2, impedes eavesdropping by forcing the attacker to
become active: either by performing a persistent man-in-the-middle
(MitM) attack, by downgrading connections to v1, or by spinning up
their own nodes and getting honest nodes to make connections to them.
Active attacks at scale are more resource intensive in general, but in
case of manual, deliberate connections (as opposed to automatic,
random ones) they are also in principle detectable: even very basic
checks, e.g., operators manually comparing protocol versions and
session IDs (as supported by the proposed protocol), will expose the
attacker.</li>
<li>Tampering, while already an inherently active attack, is costlier if
the attacker is forced to maintain the state necessary for a full MitM
interception.</li>
<li>A pseudorandom bytestream excludes identification techniques based on
pattern matching, and makes it easier to shape the bytestream in order
to mimic other protocols used on the Internet. This raises the cost of
a connection censoring firewall, forcing them to either resort to a
full MitM attack, or operate on a more obvious allowlist basis, rather
than a blocklist basis.</li>
</ul>
<p><strong>Why encrypt without authentication?</strong></p>
<p>As we have argued above, unauthenticated encryption<sup class="footnote-reference"><a href="#1">1</a></sup> (one in each
direction) using HKDF-SHA256.</p>
<p>#** Send their 16-byte garbage terminator<sup class="footnote-reference"><a href="#2">2</a></sup> followed by a <strong>garbage
authentication packet</strong><sup class="footnote-reference"><a href="#3">3</a></sup>, an <strong>encrypted packet</strong> (see further) with
arbitrary <strong>contents</strong>, and <strong>associated data</strong> equal to the garbage.</p>
<p>#** Receive up to 4111 bytes, stopping when encountering the garbage
terminator.</p>
<p>#** Receive an encrypted packet, verify that it decrypts correctly
with associated data set to the garbage received, and then ignore its
contents.</p>
<p>#* At this point, both parties have the same keys, and all further
communication proceeds in the form of encrypted packets. Packets have an
<strong>ignore bit</strong>, which makes them <strong>decoy packets</strong> if set. Decoy packets
are to be ignored by the receiver apart from verifying they decrypt
correctly. Either peer may send such decoy packets at any point after
this. These form the primary shapability mechanism in the protocol. How
and when to use them is out of scope for this document.</p>
<ol>
<li>The <strong>Version negotiation phase</strong>, where parties negotiate what
transport version they will use, as well as data defined by that
version.<sup class="footnote-reference"><a href="#4">4</a></sup>
<ul>
<li>The responder:
<ul>
<li>Sends a <strong>version packet</strong> with empty content, to indicate
support for the v2 P2P protocol proposed by this document. Any
other value for content is reserved for future versions.</li>
</ul>
</li>
<li>The initiator:
<ul>
<li>Receives a packet, ignores its contents. The idea is that
features added by future versions get negotiated based on what
is supported by both parties. Since there is just one version so
far, the contents here can simply be ignored. But in the future,
receiving a non-empty contents here may trigger other behavior;
we defer specifying the encoding for such version content until
there is a need for it.<sup class="footnote-reference"><a href="#5">5</a></sup></li>
<li>Sends a <strong>version packet</strong> with empty content as well, to
indicate support for the v2 P2P protocol.</li>
</ul>
</li>
<li>The responder:
<ul>
<li>Receives a packet, ignores its contents.</li>
</ul>
</li>
</ul>
</li>
<li>The <strong>Application phase</strong>, where the packets exchanged have contents
to be interpreted as application data.
<ul>
<li>Whenever either peer has a message to send, it sends a packet with
that application message as <strong>contents</strong>.</li>
</ul>
</li>
</ol>
<p>In order to provide a means of avoiding the recognizable pattern of
first messages being at least 64 bytes, a future backwards-compatible
upgrade to this protocol may allow both peers to send their public key +
garbage + garbage terminator in multiple rounds, slicing those bytes up
into messages arbitrarily, as long as progress is guaranteed.<sup class="footnote-reference"><a href="#6">6</a></sup></p>
<p>Note that the version negotiation phase does not need to wait for the
key exchange phase to complete; version packets can be sent immediately
after sending the garbage authentication packet. So the first two phases
together, jointly called <strong>the handshake</strong>, comprise just 1.5
roundtrips:</p>
<ul>
<li>the initiator sends public key + garbage</li>
<li>the responder sends public key + garbage + garbage terminator +
garbage authentication packet + version packet</li>
<li>the initiator sends garbage terminator + garbage authentication
packet + version packet</li>
</ul>
<p><strong>Packet encryption overview</strong></p>
<p>All data on the wire after the garbage terminators takes the form of
encrypted packets. Every packet encodes an encrypted variable-length
byte array, called the <strong>contents</strong>, as well as an <strong>ignore bit</strong> as
mentioned before. The total size of a packet is 20 bytes plus the length
of its contents.</p>
<p>Each packet consists of:</p>
<ul>
<li>A 3-byte encrypted <strong>length</strong> field, encoding the length of the
<strong>contents</strong> (between <em>0</em> and <em>2<sup>24</sup>-1</em><sup class="footnote-reference"><a href="#7">7</a></sup>, inclusive).</li>
<li>An authenticated encryption of the <strong>plaintext</strong>, which consists of:
<ul>
<li>A 1-byte <strong>header</strong> which consists of transport layer protocol
flags. Currently only the highest bit is defined as the <strong>ignore
bit</strong>. The other bits are ignored, but this may change in future
versions<sup class="footnote-reference"><a href="#8">8</a></sup>.</li>
<li>The variable-length <strong>contents</strong>.</li>
</ul>
</li>
</ul>
<p>The encryption of the plaintext uses
<strong><a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/ChaCha20-Poly1305">ChaCha20Poly1305</a></strong><sup class="footnote-reference"><a href="#9">9</a></sup>,
an <a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Authenticated_encryption">authenticated encryption with associated
data</a> (AEAD)
cipher specified in <a rel="noopener" target="_blank" href="https://datatracker.ietf.org/doc/html/rfc8439">RFC
8439</a>. Every packet's
plaintext is treated as a separate AEAD message, with a different nonce
for each.</p>
<p>The length must be dealt with specially, as it is needed to determine
packet boundaries before the whole packet is received and authenticated.
As we want a stream that is pseudorandom to a passive attacker, it still
needs encryption. We use unauthenticated<sup class="footnote-reference"><a href="#10">10</a></sup> <strong>ChaCha20</strong> encryption
for this, with an independent key. Note that the plaintext length is
still implicitly authenticated by the encryption of the plaintext, but
this can only be verified after receiving the whole packet. This design
is inspired by that of the ChaCha20Poly1305 cipher suite in
<a rel="noopener" target="_blank" href="http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305">OpenSSH</a>.<sup class="footnote-reference"><a href="#11">11</a></sup>
Because only fixed-length chunks (3-byte length fields) are encrypted,
we do not need to treat all length chunks as separate messages. Instead,
a single cipher (with the same nonce) is used for multiple consecutive
length fields. This avoids wasting 61 pseudorandom bytes per packet, and
makes the cost of having a separate cipher for length encryption
negligible.<sup class="footnote-reference"><a href="#12">12</a></sup></p>
<p>In order to provide forward security<sup class="footnote-reference"><a href="#13">13</a></sup><sup class="footnote-reference"><a href="#14">14</a></sup>, the encryption keys for
both plaintext and length encryption are cycled every 224 messages, by
switching to a new key that is generated by the key stream using the old
key.</p>
<h4 id="Handshake:_key_exchange_and_version_negotiation">Handshake: key exchange and version negotiation</h4>
<p>Next we specify the handshake of a connection in detail.</p>
<p>As explained before, these messages are sent to set up the connection:</p>
<pre style="background-color:#fafafa;color:#61676c;"><code><span> ----------------------------------------------------------------------------------------------------
</span><span> | Initiator                         Responder                                                      |
</span><span> |                                                                                                  |
</span><span> | x, ellswift_X = ellswift_create(initiating=True)                                                 |
</span><span> |                                                                                                  |
</span><span> |           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) ---&gt;        |
</span><span> |                                                                                                  |
</span><span> |                                   y, ellswift_Y = ellswift_create(initiating=False)              |
</span><span> |                                   ecdh_secret = v2_ecdh(                                         |
</span><span> |                                                     y, ellswift_X, ellswift_Y, initiating=False) |
</span><span> |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |
</span><span> |                                                                                                  |
</span><span> |           &lt;-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |
</span><span> |                    responder_garbage_terminator (16 bytes) +                                     |
</span><span> |                    v2_enc_packet(initiator, b&#39;&#39;, aad=responder_garbage) +                        |
</span><span> |                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |
</span><span> |                                                                                                  |
</span><span> | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |
</span><span> | v2_initialize(responder, ecdh_secret, initiating=True)                                           |
</span><span> |                                                                                                  |
</span><span> |            --- initiator_garbage_terminator (16 bytes) +                                         |
</span><span> |                    v2_enc_packet(responder, b&#39;&#39;, aad=initiator_garbage) +                        |
</span><span> |                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) ---&gt;                    |
</span><span> |                                                                                                  |
</span><span> ----------------------------------------------------------------------------------------------------
</span></code></pre>
<h5 id="Shared_secret_computation">Shared secret computation</h5>
<p>The peers derive their shared secret through X-only ECDH, hashed
together with the exactly 64-byte public keys' encodings sent over the
wire.</p>
<pre style="background-color:#fafafa;color:#61676c;"><code><span>def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):
</span><span>    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)
</span><span>    if initiating:
</span><span>        # Initiating, place our public key encoding first.
</span><span>        return sha256_tagged(&quot;bip324_ellswift_xonly_ecdh&quot;, ellswift_ours + ellswift_theirs + ecdh_point_x32)
</span><span>    else:
</span><span>        # Responding, place their public key encoding first.
</span><span>        return sha256_tagged(&quot;bip324_ellswift_xonly_ecdh&quot;, ellswift_theirs + ellswift_ours + ecdh_point_x32)
</span></code></pre>
<p>Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value
<code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification">BIP340</a>.</p>
<h5 id="ElligatorSwift_encoding_of_curve_X_coordinates">ElligatorSwift encoding of curve X coordinates</h5>
<p>The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate
the construction of ElligatorSwift-encoded public keys, and the
computation of X-only ECDH with ElligatorSwift-encoded public keys.</p>
<p>First we define a constant:</p>
<ul>
<li>Let <em>c =
0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852</em>.<sup class="footnote-reference"><a href="#15">15</a></sup></li>
</ul>
<p>To define the needed functions, we first introduce a helper function,
matching the <code>XSwiftEC</code> function from the
<a rel="noopener" target="_blank" href="https://eprint.iacr.org/2022/759.pdf">SwiftEC</a> paper, instantiated for
the secp256k1 curve, with minor modifications. It maps pairs of integers
<em>(u, t)</em> (both in range <em>0..p-1</em>) to valid X coordinates on the curve.
Note that the specification here does not attempt to be constant time,
as it does not operate on secret data. In what follows, we use the
notation from
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification">BIP340</a>.</p>
<ul>
<li><em>XSwiftEC(u, t)</em>:
<ul>
<li>Alter the inputs to guarantee an X coordinate on the curve:<sup class="footnote-reference"><a href="#16">16</a></sup>
<ul>
<li>If <em>u mod p = 0</em>, let <em>u = 1</em> instead.</li>
<li>If <em>t mod p = 0</em>, let <em>t = 1</em> instead.</li>
<li>If <em>(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0</em>, let <em>t = 2t
(mod p)</em> instead.</li>
</ul>
</li>
<li>Let <em>X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).</em><sup class="footnote-reference"><a href="#17">17</a></sup></li>
<li>Let <em>Y = (X + t)/(cu) (mod p)</em>.</li>
<li>For every <em>x</em> in <em>{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}</em>
(all <em>mod p</em>; the order matters):
<ul>
<li>If <em>lift_x(x)</em> succeeds, return <em>x</em>. There is at least one such
<em>x</em>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>To find encodings of a given X coordinate <em>x</em>, we first need the inverse
of <em>XSwiftEC</em>. The function <em>XSwiftECInv(x, u, case)</em> either returns <em>t</em>
such that <em>XSwiftEC(u, t) = x</em>, or <em>None</em>. The <em>case</em> variable is an
integer in range 0 to 7 inclusive, which selects which of the up to 8
valid such <em>t</em> values to return:</p>
<ul>
<li><em>XSwiftECInv(x, u, case)</em>:
<ul>
<li>If <em>case &amp; 2 = 0</em>:
<ul>
<li>If <em>lift_x(-x - u)</em> succeeds, return <em>None</em>.</li>
<li>Let <em>v = x</em>.</li>
<li>Let <em>s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>)
(mod p)</em>.</li>
</ul>
</li>
<li>If <em>case &amp; 2 = 2</em>:
<ul>
<li>Let <em>s = x - u (mod p)</em>.</li>
<li>If <em>s = 0</em>, return <em>None</em>.</li>
<li>Let <em>r</em> be the square root of <em>-s(4(u<sup>3</sup> + 7) +
3u<sup>2</sup>s) (mod p).</em><sup class="footnote-reference"><a href="#18">18</a></sup> Return <em>None</em> if it does not
exist.</li>
</ul>
</li>
<li>If <em>case &amp; 1 = 1</em> and <em>r = 0</em>, return <em>None</em>.
<ul>
<li>Let <em>v = (-u + r/s)/2</em>.</li>
</ul>
</li>
<li>Let <em>w</em> be the square root of <em>s (mod p)</em>. Return <em>None</em> if it does
not exist.</li>
<li>If <em>case &amp; 5 = 0</em>, return <em>-w(u(1 - c)/2 + v)</em>.</li>
<li>If <em>case &amp; 5 = 1</em>, return <em>w(u(1 + c)/2 + v)</em>.</li>
<li>If <em>case &amp; 5 = 4</em>, return <em>w(u(1 - c)/2 + v)</em>.</li>
<li>If <em>case &amp; 5 = 5</em>, return <em>-w(u(1 + c)/2 + v)</em>.</li>
</ul>
</li>
</ul>
<p>The overall <em>XElligatorSwift</em> algorithm, matching the name used in the
paper, then uses this inverse to randomly*<sup class="footnote-reference"><a href="#19">19</a></sup> sample encodings of*x'':</p>
<ul>
<li><em>XElligatorSwift(x)</em>:
<ul>
<li>Loop:
<ul>
<li>Let <em>u</em> be a random non-zero integer in range <em>1..p-1</em> inclusive.</li>
<li>Let <em>case</em> be a random integer in range <em>0..7</em> inclusive.</li>
<li>Compute <em>t = XSwiftECInv(x, u, case)</em>.</li>
<li>If <em>t</em> is not <em>None</em>, return <em>(u, t)</em>. Otherwise, restart loop.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This is used to define the <code>ellswift_create</code> algorithm used in the
previous section; it generates a random private key, along with a
uniformly sampled 64-byte ElligatorSwift-encoded public key
corresponding to it:</p>
<ul>
<li><em>ellswift_create()</em>:
<ul>
<li>Generate a random private key <em>priv</em> in range <em>1..p-1</em>.</li>
<li>Let <em>P = priv⋅G</em>, the corresponding public key point to <em>priv</em>.</li>
<li>Let <em>(u, t) = XElligatorSwift(x(P))</em>, an encoding of <em>x(P)</em>.</li>
<li><em>ellswift_pub = bytes(u) || bytes(t)</em>, its encoding as 64 bytes.</li>
<li>Return <em>(priv, ellswift_pub)</em>.</li>
</ul>
</li>
</ul>
<p>Finally the <code>ellswift_ecdh_xonly</code> algorithm is:</p>
<ul>
<li><em>ellswift_ecdh_xonly(ellswift_theirs, priv)</em>:
<ul>
<li>Let <em>u = int(ellswift_theirs[:32]) mod p</em>.</li>
<li>Let <em>t = int(ellswift_theirs[32:]) mod p</em>.</li>
<li>Return <em>bytes(x(priv⋅lift_x(XSwiftEC(u, t))))</em>.<sup class="footnote-reference"><a href="#20">20</a></sup></li>
</ul>
</li>
</ul>
<h5 id="Keys_and_session_ID_derivation">Keys and session ID derivation</h5>
<p>The authenticated encryption construction proposed here requires two
32-byte keys per communication direction. These (in addition to a
session ID) are computed using HKDF<sup class="footnote-reference"><a href="#21">21</a></sup> as specified in <a rel="noopener" target="_blank" href="https://tools.ietf.org/html/rfc5869">RFC
5869</a> with SHA256 as the hash
function:</p>
<pre style="background-color:#fafafa;color:#61676c;"><code><span>def initialize_v2_transport(peer, ecdh_secret, initiating):
</span><span>    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail
</span><span>    prk = HKDF_Extract(Hash=sha256, salt=b&#39;bitcoin_v2_shared_secret&#39; + NETWORK_MAGIC, ikm=ecdh_secret)
</span><span>
</span><span>    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b&#39;session_id&#39;, L=32)
</span><span>
</span><span>    # Initialize the packet encryption ciphers.
</span><span>    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b&#39;initiator_L&#39;, L=32)
</span><span>    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b&#39;initiator_P&#39;, L=32)
</span><span>    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b&#39;responder_L&#39;, L=32)
</span><span>    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b&#39;responder_P&#39;, L=32)
</span><span>    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b&#39;garbage_terminators&#39;, L=32)
</span><span>    initiator_garbage_terminator = garbage_terminators[:16]
</span><span>    responder_garbage_terminator = garbage_terminators[16:]
</span><span>
</span><span>    if initiating:
</span><span>        peer.send_L = FSChaCha20(initiator_L)
</span><span>        peer.send_P = FSChaCha20Poly1305(initiator_P)
</span><span>        peer.send_garbage_terminator = initiator_garbage_terminator
</span><span>        peer.recv_L = FSChaCha20(responder_L)
</span><span>        peer.recv_P = FSChaCha20Poly1305(responder_P)
</span><span>        peer.recv_garbage_terminator = responder_garbage_terminator
</span><span>    else:
</span><span>        peer.send_L = FSChaCha20(responder_L)
</span><span>        peer.send_P = FSChaCha20Poly1305(responder_P)
</span><span>        peer.send_garbage_terminator = responder_garbage_terminator
</span><span>        peer.recv_L = FSChaCha20(initiator_L)
</span><span>        peer.recv_P = FSChaCha20Poly1305(initiator_P)
</span><span>        peer.recv_garbage_terminator = initiator_garbage_terminator
</span><span>
</span><span>    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:
</span><span>    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)
</span></code></pre>
<p>The session ID uniquely identifies the encrypted channel. v2 clients
supporting this proposal may present the entire session ID (encoded as a
hex string) to the node operator to allow for manual, out of band
comparison with the peer node operator. Future transport versions may
introduce optional authentication methods that compare the session ID as
seen by the two endpoints in order to bind the encrypted channel to the
authentication.</p>
<h5 id="Overall_handshake_pseudocode">Overall handshake pseudocode</h5>
<p>To establish a v2 encrypted connection, the initiator generates an
ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift
encoding of the public key to the responding peer followed by
unencrypted pseudorandom bytes <code>initiator_garbage</code> of length
<code>garbage_len &lt; 4096</code>.</p>
<pre style="background-color:#fafafa;color:#61676c;"><code><span>def initiate_v2_handshake(peer, garbage_len):
</span><span>    peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)
</span><span>    peer.sent_garbage = rand_bytes(garbage_len)
</span><span>    send(peer, peer.ellswift_ours + peer.sent_garbage)
</span></code></pre>
<p>The responder generates an ephemeral keypair for itself and derives the
shared ECDH secret (using the first 64 received bytes) which enables it
to instantiate the encrypted transport. It then sends 64 bytes of the
unencrypted ElligatorSwift encoding of its own public key and its own
<code>responder_garbage</code> also of length <code>garbage_len &lt; 4096</code>. If the first 12
bytes received match the v1 prefix, the v1 protocol is used instead.</p>
<pre style="background-color:#fafafa;color:#61676c;"><code><span>TRANSPORT_VERSION = b&#39;&#39;
</span><span>NETWORK_MAGIC = b&#39;\xf9\xbe\xb4\xd9&#39; # Mainnet network magic; differs on other networks.
</span><span>V1_PREFIX = NETWORK_MAGIC + b&#39;version\x00&#39;
</span><span>
</span><span>def respond_v2_handshake(peer, garbage_len):
</span><span>    peer.received_prefix = b&quot;&quot;
</span><span>    while len(peer.received_prefix) &lt; 12:
</span><span>        peer.received_prefix += receive(peer, 1)
</span><span>        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:
</span><span>            peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)
</span><span>            peer.sent_garbage = rand_bytes(garbage_len)
</span><span>            send(peer, ellswift_Y + peer.sent_garbage)
</span><span>            return
</span><span>    use_v1_protocol()
</span></code></pre>
<p>Upon receiving the encoded responder public key, the initiator derives
the shared ECDH secret and instantiates the encrypted transport. It then
sends the derived 16-byte <code>initiator_garbage_terminator</code> followed by an
authenticated, encrypted packet with empty contents<sup class="footnote-reference"><a href="#22">22</a></sup> to authenticate
the garbage, and its own version packet. It then receives the
responder's garbage and garbage authentication packet (delimited by the
garbage terminator), and checks if the garbage is authenticated
correctly. The responder performs very similar steps, but includes the
earlier received prefix bytes in the public key. As mentioned before,
the encrypted packets for the <strong>version negotiation phase</strong> can be
piggybacked with the garbage authentication packet to minimize
roundtrips.</p>
<pre style="background-color:#fafafa;color:#61676c;"><code><span>def complete_handshake(peer, initiating):
</span><span>    received_prefix = b&#39;&#39; if initiating else peer.received_prefix
</span><span>    ellswift_theirs = receive(peer, 64 - len(received_prefix))
</span><span>    ecdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,
</span><span>                          initiating=initiating)
</span><span>    initialize_v2_transport(peer, ecdh_secret, initiating=True)
</span><span>    # Send garbage terminator + garbage authentication packet + version packet.
</span><span>    send(peer, peer.send_garbage_terminator +
</span><span>               v2_enc_packet(peer, b&#39;&#39;, aad=peer.sent_garbage) +
</span><span>               v2_enc_packet(peer, TRANSPORT_VERSION))
</span><span>    # Skip garbage, until encountering garbage terminator.
</span><span>    received_garbage = recv(peer, 16)
</span><span>    for i in range(4096):
</span><span>        if received_garbage[-16:] == peer.recv_garbage_terminator:
</span><span>            # Receive, decode, and ignore garbage authentication packet (decoy or not)
</span><span>            v2_receive_packet(peer, aad=received_garbage, skip_decoy=False)
</span><span>            # Receive, decode, and ignore version packet, skipping decoys
</span><span>            v2_receive_packet(peer)
</span><span>            return
</span><span>        else:
</span><span>            received_garbage += recv(peer, 1)
</span><span>    # Garbage terminator was not seen after 4 KiB of garbage.
</span><span>    disconnect(peer)
</span></code></pre>
<h4 id="Packet_encryption">Packet encryption</h4>
<p>Lastly, we specify the packet encryption cipher in detail.</p>
<h5 id="Existing_cryptographic_primitives">Existing cryptographic primitives</h5>
<p>Packet encryption is built on two existing primitives:</p>
<ul>
<li><strong>ChaCha20Poly1305</strong> is specified as <code>AEAD_CHACHA20_POLY1305</code> in <a rel="noopener" target="_blank" href="https://datatracker.ietf.org/doc/html/rfc8439#section-2.8">RFC
8439 section
2.8</a>. It is
an authenticated encryption protocol with associated data (AEAD),
taking a 256-bit key, 96-bit nonce, and an arbitrary-length byte array
of associated authenticated data (AAD). Due to the built-in
authentication tag, ciphertexts are 16 bytes longer than the
corresponding plaintext. In what follows:
<ul>
<li><code>aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)</code> refers
to a function that takes as input a 32-byte array <em>key</em>, a 12-byte
array <em>nonce</em>, an arbitrary-length byte array <em>aad</em>, and an
arbitrary-length byte array <em>plaintext</em>, and returns a byte array
<em>ciphertext</em>, 16 bytes longer than the plaintext.</li>
<li><code>aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)</code> refers
to a function that takes as input a 32-byte array <em>key</em>, a 12-byte
array <em>nonce</em>, an arbitrary-length byte array <em>aad</em>, and an
arbitrary-length byte array <em>ciphertext</em>, and returns either a byte
array <em>plaintext</em> (16 bytes shorter than the ciphertext), or <em>None</em>
in case the ciphertext was not a valid ChaCha20Poly1305 encryption
of any plaintext with the specified <em>key</em>, <em>nonce</em>, and <em>aad</em>.</li>
</ul>
</li>
<li>The <strong>ChaCha20 Block Function</strong> is specified in <a rel="noopener" target="_blank" href="https://datatracker.ietf.org/doc/html/rfc8439#section-2.8">RFC 8439 section
2.3</a>. It is
a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce, and
32-bit counter, and outputs 64 pseudorandom bytes. It is the
underlying building block on which ChaCha20 (and ultimately,
ChaCha20Poly1305) is built. In what follows:
<ul>
<li><code>chacha20_block(key, nonce, count)</code> refers to a function that takes
as input a 32-byte array <em>key</em>, a 12-byte array <em>nonce</em>, and an
integer <em>count</em> in range <em>0..2<sup>32</sup>-1</em>, and returns a byte
array of length 64.</li>
</ul>
</li>
</ul>
<p>These will be used for plaintext encryption and length encryption,
respectively.</p>
<h5 id="Rekeying_wrappers:_FSChaCha20Poly1305_and_FSChaCha20">Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20</h5>
<p>To provide re-keying every 224 packets, we specify two wrappers.</p>
<p>The first is <strong>FSChaCha20Poly1305</strong>, which represents a ChaCha20Poly1305
AEAD, which automatically changes the nonce after every message, and
rekeys every 224 messages by encrypting 32 zero bytes<sup class="footnote-reference"><a href="#23">23</a></sup>, and using
the first 32 bytes of the result. Each message will be used for one
packet. Note that in our protocol, any FSChaCha20Poly1305 instance is
always either exclusively encryption or exclusively decryption, as
separate instances are used for each direction of the protocol. The
nonce used for a message is composed of the 32-bit little endian
encoding of the number of messages with the current key, followed by the
64-bit little endian encoding of the number of rekeyings performed. For
rekeying, the first 32-bit integer is set to <em>0xffffffff</em>.</p>
<pre style="background-color:#fafafa;color:#61676c;"><code><span>REKEY_INTERVAL = 224
</span><span>
</span><span>class FSChaCha20Poly1305:
</span><span>    &quot;&quot;&quot;Rekeying wrapper AEAD around ChaCha20Poly1305.&quot;&quot;&quot;
</span><span>
</span><span>    def __init__(self, initial_key):
</span><span>        self.key = initial_key
</span><span>        self.packet_counter = 0
</span><span>
</span><span>    def crypt(self, aad, text, is_decrypt):
</span><span>        nonce = ((self.packet_counter % REKEY_INTERVAL).to_bytes(4, &#39;little&#39;) +
</span><span>                 (self.packet_counter // REKEY_INTERVAL).to_bytes(8, &#39;little&#39;))
</span><span>        if is_decrypt:
</span><span>            ret = aead_chacha20_poly1305_decrypt(self.key, nonce, aad, text)
</span><span>        else:
</span><span>            ret = aead_chacha20_poly1305_encrypt(self.key, nonce, aad, text)
</span><span>        if (self.packet_counter + 1) % REKEY_INTERVAL == 0:
</span><span>            rekey_nonce = b&quot;\xFF\xFF\xFF\xFF&quot; + nonce[4:]
</span><span>            self.key = aead_chacha20_poly1305_encrypt(self.key, rekey_nonce, b&quot;&quot;, b&quot;\x00&quot; * 32)[:32]
</span><span>        self.packet_counter += 1
</span><span>        return ret
</span><span>
</span><span>    def decrypt(self, aad, ciphertext):
</span><span>        return self.crypt(aad, ciphertext, True)
</span><span>
</span><span>    def encrypt(self, aad, plaintext):
</span><span>        return self.crypt(aad, plaintext, False)
</span></code></pre>
<p>The second is <strong>FSChaCha20</strong>, a (single) stream cipher which is used for
the lengths of all packets. Encryption and decryption are identical
here, so a single function <code>crypt</code> is exposed. It XORs the input with
bytes generated using the ChaCha20 block function, rekeying every 224
chunks using the next 32 bytes of the block function output as new key.
A <em>chunk</em> refers here to a single invocation of <code>crypt</code>. As explained
before, the same cipher is used for 224 consecutive chunks, to avoid
wasting cipher output. The nonce used for these batches of 224 chunks is
composed of 4 zero bytes followed by the 64-bit little endian encoding
of the number of rekeyings performed. The block counter is reset to 0
after every rekeying.</p>
<pre style="background-color:#fafafa;color:#61676c;"><code><span>class FSChaCha20:
</span><span>    &quot;&quot;&quot;Rekeying wrapper stream cipher around ChaCha20.&quot;&quot;&quot;
</span><span>
</span><span>    def __init__(self, initial_key):
</span><span>        self.key = initial_key
</span><span>        self.block_counter = 0
</span><span>        self.chunk_counter = 0
</span><span>        self.keystream = b&#39;&#39;
</span><span>
</span><span>    def get_keystream_bytes(self, nbytes):
</span><span>        while len(self.keystream) &lt; nbytes:
</span><span>            nonce = ((0).to_bytes(4, &#39;little&#39;) +
</span><span>                     (self.chunk_counter // REKEY_INTERVAL).to_bytes(8, &#39;little&#39;))
</span><span>            self.keystream += chacha20_block(self.key, nonce, self.block_counter)
</span><span>            self.block_counter += 1
</span><span>        ret = self.keystream[:nbytes]
</span><span>        self.keystream = self.keystream[nbytes:]
</span><span>        return ret
</span><span>
</span><span>    def crypt(self, chunk):
</span><span>        ks = self.get_keystream_bytes(len(chunk))
</span><span>        ret = bytes([ks[i] ^ chunk[i] for i in range(len(chunk))])
</span><span>        if ((self.chunk_counter + 1) % REKEY_INTERVAL) == 0:
</span><span>            self.key = self.get_keystream_bytes(32)
</span><span>            self.block_counter = 0
</span><span>        self.chunk_counter += 1
</span><span>        return ret
</span></code></pre>
<h5 id="Overall_packet_encryption_and_decryption_pseudocode">Overall packet encryption and decryption pseudocode</h5>
<p>Encryption and decryption of packets then follow by composing the
ciphers from the previous section as building blocks.</p>
<pre style="background-color:#fafafa;color:#61676c;"><code><span>LENGTH_FIELD_LEN = 3
</span><span>HEADER_LEN = 1
</span><span>IGNORE_BIT_POS = 7
</span><span>
</span><span>def v2_enc_packet(peer, contents, aad=b&#39;&#39;, ignore=False):
</span><span>    assert len(contents) &lt;= 2**24 - 1
</span><span>    header = (ignore &lt;&lt; IGNORE_BIT_POS).to_bytes(HEADER_LEN, &#39;little&#39;)
</span><span>    plaintext = header + contents
</span><span>    aead_ciphertext = peer.send_P.encrypt(aad, plaintext)
</span><span>    enc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, &#39;little&#39;))
</span><span>    return enc_contents_len + aead_ciphertext
</span><span>
</span><span>CHACHA20POLY1305_EXPANSION = 16
</span><span>
</span><span>def v2_receive_packet(peer, aad=b&#39;&#39;, skip_decoy=True):
</span><span>    while True:
</span><span>        enc_contents_len = receive(peer, LENGTH_FIELD_LEN)
</span><span>        contents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), &#39;little&#39;)
</span><span>        aead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)
</span><span>        plaintext = peer.recv_P.decrypt(aead_ciphertext)
</span><span>        if plaintext is None:
</span><span>            disconnect(peer)
</span><span>            break
</span><span>        header = plaintext[:HEADER_LEN]
</span><span>        if not (skip_decoy and header[0] &amp; (1 &lt;&lt; IGNORE_BIT_POS)):
</span><span>            return plaintext[HEADER_LEN:]
</span></code></pre>
<h4 id="Performance">Performance</h4>
<p>Each v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes.
Roughly the same amount of computation power is required for encrypting
and authenticating a v2 P2P message as proposed.</p>
<h3 id="Application_layer_specification">Application layer specification</h3>
<h4 id="v2_Bitcoin_P2P_message_structure">v2 Bitcoin P2P message structure</h4>
<p>v2 Bitcoin P2P transport layer packets use the encrypted message
structure shown above. An unencrypted application layer <strong>contents</strong> is
composed of:</p>
<table><thead><tr><th>Field</th><th>Size in bytes</th><th>Comments</th></tr></thead><tbody>
<tr><td><code>message_type</code></td><td><em>1..13</em></td><td>either a one byte ID or an ASCII string prefixed with a length byte</td></tr>
<tr><td><code>message_payload</code></td><td><code>message_length</code></td><td>message payload</td></tr>
</tbody></table>
<p>If the first byte of <code>message_type</code> is in the range <em>1..12</em>, it is
interpreted as the number of ASCII bytes that follow for the message
type. If it is in the range <em>13..255</em>, it is interpreted as a message
type ID. This structure results in smaller messages than the v1 protocol
as most messages sent/received will have a message type ID.<sup class="footnote-reference"><a href="#24">24</a></sup></p>
<p>The following table lists currently defined message type IDs:</p>
<table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody>
<tr><td>+0</td><td>(undefined)</td><td>(1 byte string)</td><td>(2 byte string)</td><td>(3 byte string)</td></tr>
<tr><td>+4</td><td>(4 byte string)</td><td>(5 byte string)</td><td>(6 byte string)</td><td>(7 byte string)</td></tr>
<tr><td>+8</td><td>(8 byte string)</td><td>(9 byte string)</td><td>(10 byte string)</td><td>(11 byte string)</td></tr>
<tr><td>+12</td><td>(12 byte string)</td><td><code>ADDR</code></td><td><code>BLOCK</code></td><td><code>BLOCKTXN</code></td></tr>
<tr><td>+16</td><td><code>CMPCTBLOCK</code></td><td><code>FEEFILTER</code></td><td><code>FILTERADD</code></td><td><code>FILTERCLEAR</code></td></tr>
<tr><td>+20</td><td><code>FILTERLOAD</code></td><td><code>GETADDR</code></td><td><code>GETBLOCKS</code></td><td><code>GETBLOCKTXN</code></td></tr>
<tr><td>+24</td><td><code>GETDATA</code></td><td><code>GETHEADERS</code></td><td><code>HEADERS</code></td><td><code>INV</code></td></tr>
<tr><td>+28</td><td><code>MEMPOOL</code></td><td><code>MERKLEBLOCK</code></td><td><code>NOTFOUND</code></td><td><code>PING</code></td></tr>
<tr><td>+32</td><td><code>PONG</code></td><td><code>SENDCMPCT</code></td><td><code>SENDHEADERS</code></td><td><code>TX</code></td></tr>
<tr><td>+36</td><td><code>VERACK</code></td><td><code>VERSION</code></td><td><code>GETCFILTERS</code></td><td><code>CFILTER</code></td></tr>
<tr><td>+40</td><td><code>GETCFHEADERS</code></td><td><code>CFHEADERS</code></td><td><code>GETCFCHECKPT</code></td><td><code>CFCHECKPT</code></td></tr>
<tr><td>+44</td><td><code>WTXIDRELAY</code></td><td><code>ADDRV2</code></td><td><code>SENDADDRV2</code></td><td><code>SENDTXRCNCL</code></td></tr>
<tr><td>+48</td><td><code>REQRECON</code></td><td><code>SKETCH</code></td><td><code>REQSKETCHEXT</code></td><td><code>RECONCILDIFF</code></td></tr>
<tr><td>≥52</td><td>(undefined)</td><td></td><td></td><td></td></tr>
</tbody></table>
<p>The message types may be updated separately after BIP finalization.</p>
<h3 id="Signaling_specification">Signaling specification</h3>
<h4 id="Signaling_v2_support">Signaling v2 support</h4>
<p>Peers supporting the v2 transport protocol signal support by advertising
the <code>NODE_P2P_V2 = (1 &lt;&lt; 11)</code> service flag in addr relay. If met with
immediate disconnection when establishing a v2 connection, clients
implementing this proposal are encouraged to retry connecting using the
v1 protocol.<sup class="footnote-reference"><a href="#25">25</a></sup></p>
<h2 id="Test_Vectors">Test Vectors</h2>
<p>For development and testing purposes, we provide a collection of test
vectors in CSV format, and a naive, highly inefficient, <a href="bip-0324/reference.py" title="wikilink">reference
implementation</a> of the relevant
algorithms. This code is for demonstration purposes only:</p>
<ul>
<li><a href="bip-0324/ellswift_decode_test_vectors.csv" title="wikilink">XElligatorSwift decoding
vectors</a> give
examples of ElligatorSwift-encoded public keys, and the X coordinate
they map to.</li>
<li><a href="bip-0324/xswiftec_inv_test_vectors.csv" title="wikilink">XSwiftECInv
vectors</a> give
examples of <em>(u, x)</em> pairs, and the various <em>t</em> values that
<em>xswiftec_inv</em> maps them to.</li>
<li><a href="bip-0324/packet_encoding_test_vectors.csv" title="wikilink">Packet encoding
vectors</a>
illustrate the lifecycle of the authenticated encryption scheme
proposed in this document.</li>
</ul>
<h2 id="Rationale_and_References">Rationale and References</h2>
<references/>
<h2 id="Acknowledgements">Acknowledgements</h2>
<p>Thanks to everyone (last name order) that helped invent and develop the
ideas in this proposal:</p>
<ul>
<li>Matt Corallo</li>
<li>Lloyd Fournier</li>
<li>Gregory Maxwell</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><strong>What does <em>authentication</em> mean in this context?</strong>
Unfortunately, the term authentication in the context of secure
channel protocols is ambiguous. It can refer to:</p>
</div>
<pre style="background-color:#fafafa;color:#61676c;"><code><span>- The encryption scheme guaranteeing that a message obtained via
</span><span>  successful decryption was encrypted by someone having access to
</span><span>  the (symmetric) encryption key, and not modified after encryption
</span><span>  by a third party. The proposal in this document achieves that
</span><span>  property through the use of an AEAD.
</span><span>- The communication protocol establishing that the communication
</span><span>  partner&#39;s identity matches who we expect them to be, through some
</span><span>  public key mechanism. The proposal in this document does **not**
</span><span>  include such a mechanism.
</span><span>  &lt;/ref&gt;
</span><span>
</span><span>  provides strictly better security than no encryption. Thus all
</span><span>  connections should use encryption, even if they are
</span><span>  unauthenticated.
</span><span>
</span><span>When it comes to authentication, the situation is not as clear as
</span><span>for encryption. Due to Bitcoin&#39;s permissionless nature,
</span><span>authentication will always be restricted to specific scenarios
</span><span>(e.g., connections between peers belonging to the same operator),
</span><span>and whether some form of (possibly partially anonymous)
</span><span>authentication is desired depends on the specific requirements of
</span><span>the involved peers. As a consequence, we believe that authentication
</span><span>should be addressed separately (if desired), and this proposal aims
</span><span>to provide a solid technical basis for future protocol upgrades,
</span><span>including the addition of optional authentication (see [Private
</span><span>authentication
</span><span>protocols](https://github.com/sipa/writeups/tree/main/private-authentication-protocols)).
</span><span>
</span><span>**Why have a pseudorandom bytestream when traffic analysis is still
</span><span>possible?**
</span><span>
</span><span>Traffic analysis, e.g., observing packet lengths and timing, as well
</span><span>as active attacks can still reveal that the Bitcoin v2 P2P protocol
</span><span>is in use. Nevertheless, a pseudorandom bytestream raises the cost
</span><span>of fingerprinting the protocol substantially, and may force some
</span><span>intermediaries to attack any protocol they cannot identify, causing
</span><span>collateral cost.
</span><span>
</span><span>A pseudorandom bytestream is not self-identifying. Moreover, it is
</span><span>unopinionated and thus a canonical choice for similar protocols. As
</span><span>a result, Bitcoin P2P traffic will be indistinguishable from traffic
</span><span>of other protocols which make the same choice (e.g.,
</span><span>[obfs4](https://gitlab.com/yawning/obfs4) and a recently proposed
</span><span>[cTLS
</span><span>extension](https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/)).
</span><span>Moreover, traffic shapers and protocol wrappers (for example, making
</span><span>the traffic look like HTTPS or SSH) can further mitigate traffic
</span><span>analysis and active attacks but are out of scope for this proposal.
</span><span>
</span><span>**Why not use a secure tunnel protocol?**
</span><span>
</span><span>Our goal includes making opportunistic encryption ubiquitously
</span><span>available, as that provides the best defense against large-scale
</span><span>attacks. That implies protecting both the manual, deliberate
</span><span>connections node operators instruct their software to make, as well
</span><span>as the the automatic connections Bitcoin nodes make with each other
</span><span>based on IP addresses obtained via gossip. While encryption per se
</span><span>is already possible with proxy networks or VPN networks, these are
</span><span>not desirable or applicable for automatic connections at scale:
</span><span>
</span><span>- Proxy networks like Tor or I2P introduce a separate address space,
</span><span>  independent from network topology, with a very low cost per
</span><span>  address making eclipse attacks cheaper. In comparison, clearnet
</span><span>  IPv4 and IPv6 networks make obtaining multiple network identities
</span><span>  in distinct, well-known network partitions carry a non-trivial
</span><span>  cost. Thus, it is not desirable to have a substantial portion of
</span><span>  nodes be exclusively connected this way, as this would
</span><span>  significantly reduce Eclipse attack costs.[^26] Additionally, Tor
</span><span>  connections come with significant bandwidth and latency costs that
</span><span>  may not be desirable for all network users.
</span><span>- VPN networks like WireGuard or OpenVPN inherently define a private
</span><span>  network, which requires manual configuration and therefore is not
</span><span>  a realistic avenue for automatic connections.
</span><span>
</span><span>Thus, to achieve our goal, we need a solution that has minimal
</span><span>costs, works without configuration, and is always enabled – on top
</span><span>of any network layer rather than be part of the network layer.
</span><span>
</span><span>**Why not use a general-purpose transport encryption protocol?**
</span><span>
</span><span>While it would be possible to rely on an off-the-shelf transport
</span><span>encryption protocol such as TLS or Noise, the specific requirements
</span><span>of the Bitcoin P2P network laid out above make these protocols an
</span><span>unsuitable choice.
</span><span>
</span><span>The primary requirement which existing protocols fail to meet is a
</span><span>sufficiently modular treatment of encryption and authentication. As
</span><span>we argue above, whether and which form of authentication is desired
</span><span>in the Bitcoin P2P network will depend on the specific requirements
</span><span>of the involved peers (resulting in a mix of authenticated and
</span><span>unauthenticated connections), and thus the question of
</span><span>authentication should be decoupled from encryption. However, native
</span><span>support for a handful of standard authentication scenarios (e.g.,
</span><span>using digital signatures and certificates) is at core of the design
</span><span>of existing general-purpose transport encryption protocols. This
</span><span>focus on authentication would not provide clear benefits for the
</span><span>Bitcoin P2P network but would come with a large amount of additional
</span><span>complexity.
</span><span>
</span><span>In contrast, our proposal instead aims for simple modular design
</span><span>that makes it possible to address authentication separately. Our
</span><span>proposal provides a foundation for authentication by exporting a
</span><span>*session ID* that uniquely identifies the encrypted channel. After
</span><span>an encrypted channel has been established, the two endpoints are
</span><span>able to use any authentication protocol to confirm that they have
</span><span>the same session ID. (This is sometimes called *channel binding*
</span><span>because the session ID binds the encrypted channel to the
</span><span>authentication protocol.) Since in our proposal, any authentication
</span><span>needs to run after an encrypted connection has been established, the
</span><span>price we pay for this modularity is a possibly higher number of
</span><span>roundtrips as opposed to other protocols that perform authentication
</span><span>alongside with the Diffie-Hellman key exchange.[^27] However, the
</span><span>resulting increase in connection establishment latency is a not a
</span><span>concern for Bitcoin&#39;s long-lived connections, [which typically live
</span><span>for hours or even weeks](https://www.dsn.kastel.kit.edu/bitcoin/).
</span><span>
</span><span>Besides this fundamentally different treatment of authentication,
</span><span>further technical issues arise when applying TLS or Noise to our
</span><span>desired use case:
</span><span>
</span><span>- Neither offers a pseudorandom bytestream.
</span><span>- Neither offers native support for elliptic curve cryptography on
</span><span>  the curve secp256k1 as otherwise used in Bitcoin. While using
</span><span>  secp256k1 is not strictly necessary, it is the obvious choice is
</span><span>  for any new asymmetric cryptography in Bitcoin because it
</span><span>  minimizes the cryptographic hardness assumptions as well as the
</span><span>  dependencies that Bitcoin software will need.
</span><span>- Neither offers shapability of the bytestream.
</span><span>- Both provide a stream-based interface to the application layer
</span><span>  whereas Bitcoin requires a packet-based interface, resulting in
</span><span>  the need for an additional thin layer to perform packet
</span><span>  serialization and deserialization.
</span><span>
</span><span>While existing protocols could be amended to address all of the
</span><span>aforementioned issues, this would negate the benefits of using them
</span><span>as off-the-shelf solution, e.g., the possibility to re-use existing
</span><span>implementations and security analyses.
</span><span>
</span><span>## Goals
</span><span>
</span><span>This proposal aims to achieve the following properties:
</span><span>
</span><span>- Confidentiality against passive attacks: A passive attacker having
</span><span>  recorded a v2 P2P bytestream (without timing and fragmentation
</span><span>  information) must not be able to determine the plaintext being
</span><span>  exchanged by the nodes.
</span><span>- Observability of active attacks: A session ID identifying the
</span><span>  encrypted channel uniquely is derived deterministically from a
</span><span>  Diffie-Hellman negotiation. An active man-in-the-middle attacker
</span><span>  is forced to incur a risk of being detected as peer operators can
</span><span>  compare session IDs manually, or using optional authentication
</span><span>  methods possibly introduced in future protocol versions.
</span><span>- Pseudorandom bytestream: A passive attacker having recorded a v2
</span><span>  P2P bytestream (without timing information and fragmentation
</span><span>  information) must not be able to distinguish it from a uniformly
</span><span>  random bytestream.
</span><span>- Shapable bytestream: It should be possible to shape the bytestream
</span><span>  to increase resistance to traffic analysis (for example, to
</span><span>  conceal block propagation), or censorship avoidance.[^28]
</span><span>- Forward secrecy: An eavesdropping attacker who compromises a
</span><span>  peer&#39;s sessions secrets should not be able to decrypt past session
</span><span>  traffic, except for the latest few packets.
</span><span>- Upgradability: The proposal provides an upgrade path using
</span><span>  transport versioning which can be used to add features like
</span><span>  authentication, PQC handshake upgrade, etc. in the future.
</span><span>- Compatibility: v2 clients will allow inbound v1 connections to
</span><span>  minimize risk of network partitions.
</span><span>- Low overhead: the introduction of a new P2P transport protocol
</span><span>  should not substantially increase computational cost or bandwidth
</span><span>  for nodes that implement it, compared to the current protocol.
</span><span>
</span><span>## Specification
</span><span>
</span><span>The specification consists of three parts:
</span><span>
</span><span>- The **Transport layer** concerns how to set up an encrypted
</span><span>  connection between two nodes, capable of transporting
</span><span>  application-level messages between them.
</span><span>- The **Application layer** concerns how to encode Bitcoin P2P
</span><span>  messages and commands for transport by the Transport Layer.
</span><span>- The **Signaling** concerns how v2 nodes advertise their support
</span><span>  for the v2 protocol to potential peers.
</span><span>
</span><span>### Transport layer specification
</span><span>
</span><span>In this section we define the encryption protocol for messages
</span><span>between peers.
</span><span>
</span><span>#### Overview and design
</span><span>
</span><span>We first give an informal overview of the entire protocol flow and
</span><span>packet encryption.
</span><span>
</span><span>**Protocol flow overview**
</span><span>
</span><span>Given a newly-established connection (typically TCP/IP) between two
</span><span>v2 P2P nodes, there are 3 phases the connection goes through. The
</span><span>first starts immediately, i.e. there are no v1 messages or any other
</span><span>bytes exchanged on the link beforehand. The two parties are called
</span><span>the **initiator** (who established the connection) and the
</span><span>**responder** (who accepted the connection).
</span><span>
</span><span>1.  The **Key exchange phase**, where nodes exchange data to
</span><span>    establish shared secrets.
</span><span>    - The initiator:
</span><span>      - Generates a random ephemeral secp256k1 private key and sends
</span><span>        a corresponding 64-byte ElligatorSwift[^29][^30]-encoded
</span><span>        public key to the responder.
</span><span>      - May send up to 4095[^31] bytes of arbitrary data after their
</span><span>        public key, called **garbage**, providing a form of
</span><span>        shapability and avoiding a recognizable pattern of exactly
</span><span>        64 bytes.[^32]
</span><span>    - The responder:
</span><span>      - Waits until one byte is received which does not match the 12
</span><span>        bytes consisting of the network magic followed by
</span><span>        &quot;version\x00&quot;. If the first 12 bytes do match, the
</span><span>        connection is treated as using the v1 protocol
</span><span>        instead.[^33][^34]
</span><span>      - Similarly generates a random ephemeral private key and sends
</span><span>        a corresponding 64-byte ElligatorSwift-encoded public key to
</span><span>        the initiator.
</span><span>      - Similarly may send up to 4095 bytes of garbage data after
</span><span>        their public key.
</span><span>    - Both parties:
</span><span>      - Receive (the remainder of) the full 64-byte public key from
</span><span>        the other side.
</span><span>      - Use X-only[^35] ECDH to compute a shared secret from their
</span><span>        private key and the exchanged public keys[^36], and
</span><span>        deterministically derive from the secret 4 **encryption
</span><span>        keys** (two in each direction: one for packet lengths, one
</span><span>        for content encryption), a **session id**, and two 16-byte
</span><span>        **garbage terminators**[^37]&lt;ref&gt;**What does a garbage
</span><span>        terminator in the wild look like?**
</span><span>        &lt;div&gt;
</span><span>
</span><span>        &lt;figure&gt;
</span><span>        &lt;img src=&quot;bip-0324/garbage_terminator.png&quot;
</span><span>        title=&quot;A garbage terminator model TX-v2 in the wild... sent by the responder&quot;
</span><span>        width=&quot;256&quot;
</span><span>        alt=&quot;A garbage terminator model TX-v2 in the wild... sent by the responder&quot; /&gt;
</span><span>        &lt;figcaption aria-hidden=&quot;true&quot;&gt;A garbage terminator model TX-v2 in the
</span><span>        wild... sent by the responder&lt;/figcaption&gt;
</span><span>        &lt;/figure&gt;
</span><span>
</span><span>        &lt;/div&gt;
</span></code></pre>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><strong>Why does the protocol need a garbage terminator?</strong> While it is
in principle possible to use the garbage authentication packet
directly as a terminator (scan until a valid authentication packet
follows), this would be significantly slower than just scanning for
a fixed byte sequence, as it would require recomputing a Poly1305
tag after every received byte.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><strong>Why does the protocol require a garbage authentication packet?</strong>
Otherwise the garbage would be modifiable by a third party without
consequences. We want to force any active attacker to have to
maintain a full protocol state. In addition, such malleability
without the consequence of connection termination could enable
protocol fingerprinting.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p><strong>What features could be added in future protocol versions?</strong>
Examples of features that could be added in future versions include
post-quantum cryptography upgrades to the handshake, and optional
authentication.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p><strong>How will future versions encode version numbers in the version
packet?</strong> Future versions could, for example, specify that the
contents of the version packet is to be interpreted as an integer
version number (with empty representing 0), and if the minimum of
both numbers is N, that being interpreted as choosing a &quot;v2.N&quot;
protocol version. Alternatively, certain bytes of the version packet
contents could be interpreted as a bitvector of optional features.</p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p><strong>How can progress be guaranteed in a backwards-compatible way?</strong>
In order to guarantee progress, it must be ensured that no deadlock
occurs, i.e., no state is reached in which each party waits for the
other party indefinitely. For example, any upgrade that adheres to
the following conditions will guarantee progress:</p>
</div>
<pre style="background-color:#fafafa;color:#61676c;"><code><span>- The initiator must start by sending at least as many bytes as
</span><span>  necessary to mismatch the magic/version 12 bytes prefix.
</span><span>- The responder must start sending after having received at least
</span><span>  one byte that mismatches that 12-byte prefix.
</span><span>- As soon as either party has received the other peer&#39;s garbage
</span><span>  terminator, or has received 4095 bytes of garbage, they must send
</span><span>  their own garbage terminator. (When either of these conditions is
</span><span>  met, the other party has nothing to respond with anymore that
</span><span>  would be needed to guarantee progress otherwise.)
</span><span>- Whenever either party receives any nonzero number of bytes, while
</span><span>  not having sent their garbage terminator completely yet, they must
</span><span>  send at least one byte in response without waiting for more bytes.
</span><span>- After either party has sent their garbage terminator, they must
</span><span>  also send the garbage authentication packet without waiting for
</span><span>  more bytes, and transition to the version negotiation phase.
</span><span>
</span><span>Since the protocol as specified here adheres to these conditions,
</span><span>any upgrade which also adheres to these conditions will be
</span><span>backwards-compatible.
</span></code></pre>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">7</sup>
<p><strong>Is <em>2<sup>24</sup>-1</em> bytes sufficient as maximum content
size?</strong> The current Bitcoin P2P protocol has no messages which
support more than 4000000 bytes of application payload. By
supporting up to <em>2<sup>24</sup>-1</em> we can accommodate future
evolutions needing more than 4 times that value. Hypothetical
protocol changes that have even more data to exchange than that
should probably use multiple separate messages anyway, because of
the per-peer receive buffer sizes involved, and the inability to
start processing a message before it is fully received. Of course,
future versions of the transport protocol could change the size of
the length field, if this were really needed.</p>
</div>
<div class="footnote-definition" id="8"><sup class="footnote-definition-label">8</sup>
<p><strong>Why is the header a part of the plaintext and not included
alongside the length field?</strong> The packet length field is the minimum
information that must be available before we can leverage the
standard RFC8439 AEAD. Any other data, including metadata like the
header being in the content encryption makes it easier to reason
about the protocol security w.r.t. data being used before it is
authenticated. If the ignore bit was not part of the content,
another mechanism would be needed to authenticate it; for example,
it could be fed as AAD to the AEAD cipher. We feel the complexity of
such an approach outweighs the benefit of saving one byte per
message.</p>
</div>
<div class="footnote-definition" id="9"><sup class="footnote-definition-label">9</sup>
<p><strong>Why is ChaCha20Poly1305 chosen as basis for packet encryption?</strong>
It is a very widely used authenticated encryption cipher (used
amongst others in SSH, TLS 1.2, TLS 1.3,
<a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/QUIC">QUIC</a>, Noise, and
<a rel="noopener" target="_blank" href="https://www.wireguard.com/protocol/">WireGuard</a>; in the latter it
is currently even the only supported cipher), with very good
performance in general purpose software implementations. While
AES-based ciphers (including the winners in the
<a rel="noopener" target="_blank" href="https://competitions.cr.yp.to/caesar.html">CAESAR</a> competition in
non-lightweight categories) perform significantly better on systems
with AES hardware acceleration, they are also significantly slower
in pure software implementations. We choose to optimize for the
weakest hardware.</p>
</div>
<div class="footnote-definition" id="10"><sup class="footnote-definition-label">10</sup>
<p><strong>Why is the length encryption not separately authenticated?</strong>
Informally, the relevant security goal we aim for is to hide the
number of packets and their lengths (i.e., the packet boundaries)
against a passive attacker that receives the bytestream without
timing or fragmentation information. (A formal definition can be
found for example in <a rel="noopener" target="_blank" href="https://himsen.github.io/pdf/thesis.pdf">Hansen 2016 (Definition
22)</a> under the name
&quot;boundary hiding against chosen-plaintext attacks (BH-CPA)&quot;.)
However, we do not aim to hide packet boundaries against active
attackers because active attackers can always exploit the fact that
the Bitcoin P2P protocol is largely query-response based: they can
trickle the bytes on the stream one-by-one unmodified and observe
when a response comes (see <a rel="noopener" target="_blank" href="https://himsen.github.io/pdf/thesis.pdf">Hansen 2016 (Section
3.9)</a> for a in-depth
discussion). With that in mind, we accept that an active (non-MitM)
attacker is able to figure out some information about packet
boundaries by flipping certain bits in the unauthenticated length
field, and observing the other side disconnecting immediately or
later. Thus, we choose to use unauthenticated encryption for the
length data, which is sufficient to achieve boundary hiding against
passive attackers, and saves 16 bytes of bandwidth per packet.</p>
</div>
<div class="footnote-definition" id="11"><sup class="footnote-definition-label">11</sup>
<p><strong>How does packet encryption differ from the OpenSSH design?</strong>
The differences are:</p>
</div>
<pre style="background-color:#fafafa;color:#61676c;"><code><span>- The length field is only 3 bytes instead of 4, as that is
</span><span>  sufficient for our purposes.
</span><span>- Length encryption keeps drawing pseudorandom bytes from the same
</span><span>  ChaCha20 cipher for multiple packets, rather than incrementing the
</span><span>  nonce for every packet.
</span><span>- The Poly1305 authentication tag only covers the encrypted
</span><span>  plaintext, and not the encrypted length field. This means that
</span><span>  plaintext encryption uses the standard ChaCha20Poly1305
</span><span>  construction without any modifications, maximizing applicability
</span><span>  of analysis and review of that cipher. The length encryption can
</span><span>  be seen as a separate layer, using a separate key, and thus cannot
</span><span>  affect any of the confidentiality or integrity guarantees of the
</span><span>  plaintext encryption. On the other hand, this change w.r.t.
</span><span>  OpenSSH also does not worsen any properties, as incorrect lengths
</span><span>  will still trigger authentication failure for the overall packet
</span><span>  (the plaintext length is implicitly authenticated by
</span><span>  ChaCha20Poly1305).
</span><span>- A hash step is performed every 224[^38] messages to rekey the the
</span><span>  encryption ciphers, in order to provide forward security.
</span></code></pre>
<div class="footnote-definition" id="12"><sup class="footnote-definition-label">12</sup>
<p><strong>Is it acceptable to use a less standard construction for length
encryption?</strong> The fact that multiple (non-overlapping) bytes
generated by a single ChaCha20 cipher are used for the encryption of
multiple consecutive length fields is uncommon. We feel the
performance cost gained by this deviation is worth it (especially
for small packets, which are very common in Bitcoin's P2P protocol),
given the low guarantees that are feasible for length encryption in
the first place, and the result is still sufficient to provide
pseudorandomness from the view of passive attackers. For plaintext
encryption, we independently use a very standard construction, as
the stakes for confidentiality and integrity there are much higher.</p>
</div>
<div class="footnote-definition" id="13"><sup class="footnote-definition-label">13</sup>
<p><strong>What value does forward security provide?</strong> Re-keying ensures
<a rel="noopener" target="_blank" href="https://eprint.iacr.org/2001/035.pdf">forward secrecy within a
session</a>, i.e., an attacker
compromising the current session secrets cannot derive past
encryption keys in the same session.</p>
</div>
<div class="footnote-definition" id="14"><sup class="footnote-definition-label">14</sup>
<p><strong>Why have a cipher with forward secrecy but no periodical
refresh of the ECDH key exchange?</strong> Our cipher ratchets encryption
keys forward in order to protect messages encrypted under <em>past</em>
encryption keys. In contrast, re-performing ECDH key exchange would
protect messages encrypted under <em>future</em> encryption keys, i.e., it
would re-establish security after the attacker had compromised one
of the peers <em>temporarily</em> (e.g., the attacker obtains a memory
dump). We do not believe protecting against that is a priority: an
attacker that, for whatever reason, is capable of an attack that
reveals encryption keys (or other session secrets) of a peer once is
likely capable of performing the same attack again after peers have
re-performed the ECDH key exchange. Thus, we do not believe the
benefits of re-performing key exchange outweigh the additional
complexity that comes with the necessary coordination between the
peers. We note that the initiator could choose to close and re-open
the entire connection in order to force a refresh of the ECDH key
exchange, but that introduces other issues: a connection slot needs
to be kept open at the responder side, it is not cryptographically
guaranteed that really the same initiator will use it, and the
observable TCP reset and handshake may create a detectable pattern.</p>
</div>
<div class="footnote-definition" id="15"><sup class="footnote-definition-label">15</sup>
<p><strong>What is the <em>c</em> constant used in <em>XSwiftEC</em>?</strong> The algorithm
requires a constant <em>√-3 (mod p)</em>; in other words, a number <em>c</em> such
that <em>-c<sup>2</sup> mod p = 3</em>. There are two solutions to this
equation, one which is itself a square modulo <em>p</em>, and its negation.
We choose the square one.</p>
</div>
<div class="footnote-definition" id="16"><sup class="footnote-definition-label">16</sup>
<p><strong>Why do the inputs to the XSwiftEC algorithm need to be
altered?</strong> This step deviates from the paper, which maps a
negligibly small subset of inputs (around <em>3/2<sup>256</sup></em>) to
the point at infinity. To avoid the need to deal with the case where
a peer could craft encodings that intentionally trigger this edge
case, we remap them to inputs that yield a valid X coordinate.</p>
</div>
<div class="footnote-definition" id="17"><sup class="footnote-definition-label">17</sup>
<p><strong>What does the division (/) sign in modular arithmetic refer
to?</strong> Note that the division in these expressions corresponds to
multiplication with the modular inverse modulo <em>p</em>, i.e. <em>a / b (mod
p)</em> with nonzero <em>b</em> is the unique solution <em>x</em> for which <em>bx = a
(mod p)</em>. It can be computed as <em>ab<sup>p-2</sup> (mod p)</em>, but more
efficient algorithms exist.</p>
</div>
<div class="footnote-definition" id="18"><sup class="footnote-definition-label">18</sup>
<p><strong>How to compute a square root mod <em>p</em>?</strong> Due to the structure of
<em>p</em>, a candidate for the square root of <em>a</em> mod <em>p</em> can be computed
as <em>x = a<sup>(p+1)/4</sup> mod p</em>. If <em>a</em> is not a square mod <em>p</em>,
this formula returns the square root of <em>-a mod p</em> instead, so it is
necessary to verify that <em>x<sup>2</sup> mod p = a</em>. If that is the
case <em>-x mod p</em> is a solution too, but we define &quot;the&quot; square root
to be equal to that expression (the square root will therefore
always be a square itself, as <em>(p+1)/4</em> is even). This algorithm is
a specialization of the <a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm">Tonelli-Shanks
algorithm</a>.</p>
</div>
<div class="footnote-definition" id="19"><sup class="footnote-definition-label">19</sup>
<p><strong>Can the ElligatorSwift encoding be used to construct public key
encodings that satisfy a certain structure (and not pseudorandom)?</strong>
The algorithm chooses the first 32 bytes (i.e., the value <em>u</em>) and
then computes a corresponding <em>t</em> such that the mapping to the curve
point holds. In general, picking <em>u</em> from a uniformly random
distribution provides pseudorandomness. But we can also fix any of
the 32 bytes in <em>u</em>, and the algorithm will still find a
corresponding <em>t</em>. The fact that it is possible to fix the first 32
bytes, combined with the garbage bytes in the handshake, provides a
limited but very simple method of parroting other protocols such as
<a rel="noopener" target="_blank" href="https://tls13.xargs.org/">TLS 1.3</a>, which can be deployed by one of
the peers without explicit support from the other peer. More general
methods of parroting, e.g., introduced by defining new protocol or a
protocol upgrade, are not precluded.</p>
</div>
<div class="footnote-definition" id="20"><sup class="footnote-definition-label">20</sup>
<p><strong>Does it matter which point <em>lift_x</em> maps to?</strong> Either point is
valid, as they are negations of each other, and negations do not
affect the output X coordinate.</p>
</div>
<div class="footnote-definition" id="21"><sup class="footnote-definition-label">21</sup>
<p><strong>Why use HKDF for deriving key material?</strong> The shared secret
already involves a hash function to make sure the public key
encodings contribute to it, which negates some of the need for HKDF
already. We still use it as it is the standard mechanism for
deriving many keys from a single secret, and its computational cost
is low enough to be negligible compared to the rest of a connection
setup.</p>
</div>
<div class="footnote-definition" id="22"><sup class="footnote-definition-label">22</sup>
<p><strong>Does the content of the garbage authentication packet need to
be empty?</strong> The receiver ignores the content of the garbage
authentication packet, so its content can be anything, and it can in
principle be used as a shaping mechanism too. There is however no
need for that, as immediately afterwards the initiator can start
using decoy packets as (much more flexible) shaping mechanism
instead.</p>
</div>
<div class="footnote-definition" id="23"><sup class="footnote-definition-label">23</sup>
<p><strong>Why is rekeying implemented in terms of an invocation of the
AEAD?</strong> This means the FSChaCha20Poly1305 wrapper can be thought of
as a pure layer around the ChaCha20Poly1305 AEAD. Actual
implementations can take advantage of the fact that this formulation
is equivalent to using byte 64 through 95 of the keystream output of
the underlying ChaCha20 cipher as new key, avoiding the need for
Poly1305 in the process.</p>
</div>
<div class="footnote-definition" id="24"><sup class="footnote-definition-label">24</sup>
<p><strong>How do the length between v1 and v2 compare?</strong> For messages
that use the 1-byte short message type ID, v2 packets use 3 bytes
less per message than v1.</p>
</div>
<div class="footnote-definition" id="25"><sup class="footnote-definition-label">25</sup>
<p><strong>Why are v2 clients met with immediate disconnection encouraged
to retry with a v1 connection?</strong> Service flags propagated through
untrusted intermediaries using ADDR and ADDRV2 P2P messages and are
OR'ed when received from multiple sources. An untrusted intermediary
could falsely advertise a potential peer as supportive of v2
connections. Connection downgrades to v1 mitigate the risk of a
network participant being blackholed via false advertising.</p>
</div>

    </div>

        </div>
    </section>
    <footer class="footer">
        <div class="container has-text-centered has-text-weight-bold is-family-monospace">
            <p class="mb-1">Updated <span class="tag is-medium is-warning is-light">2023-04-15</span></p>
            <p>bips.dev - Made with &#x2615; by <a href="https://twitter.com/nickmonad">nickmonad</a></p>
            <p>Check it out on <a href="https://github.com/nickmonad/bips-dev">GitHub</a></p>
            <p>Stay humble. Stack sats. &#x20bf;</p>
        </div>
    </footer>

     
</body>
</html>
